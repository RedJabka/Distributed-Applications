Данная работа выполняется на основе распределенной системы, реализованной в
pa1. При этом понятие «полезной» работы дочернего процесса определяется
следующим образом: каждый дочерний процесс должен N = process_local_id * 5 раз
распечатать сообщение, определенное строкой форматирования log_loop_operation_fmt,
посредством вызова функции print(), входящей в состав прилагаемой библиотеки
libruntime.so. Обратите внимание, что при формировании строки на основе
log_loop_operation_fmt нумерация итераций должна выполняться, начиная с единицы, а не
с ноля.

В IPC из pa1 следует внести следующие изменения: вызовы read() и write()
должны быть неблокирующими, как в pa2, а сообщения должны содержать значение
скалярных часов отправителя, как в pa3. Это фактически означает, что можно
использовать без изменений библиотеку IPC, реализованную pa3.
При запуске программы с параметром командой строки «--mutexl» перед каждым
вызовом print() процесс должен входить в критическую область, а после вызова выходить
из нее, т.е. запрещается выполнять несколько вызовов print() в пределах одной
критической области. При отсутствии параметра «--mutexl» программа должна
выполняться без использования критической области, обратите внимание на разницу в
выводе программы при использовании критической секции и без нее.
Вход в критическую область выполняется с помощью вызова функции request_cs(),
выход — release_cs(). Обе функции необходимо реализовать самостоятельно, используя
алгоритм взаимного исключения Лэмпорта. Для этого определены следующие пустые
сообщения: CS_REQUEST, CS_REPLY и CS_RELEASE. Идентификатор процесса-
отправителя данных сообщений определяется по дескриптору канала, через который
сообщение получено. Значение локальных часов отправителя извлекается из заголовка
сообщения.
